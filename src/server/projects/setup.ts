import * as fs from "node:fs/promises";
import * as path from "node:path";
import { logger } from "@/server/logger";
import { allocateProjectProductionPort } from "@/server/ports/allocate";
import {
	getProjectPath,
	getProjectPreviewPath,
	getProjectProductionPath,
	getProjectsPath,
	getTemplatePath,
} from "./paths";

export interface SetupProjectFilesystemResult {
	projectPath: string;
	productionPort: number;
}

export async function setupProjectFilesystem(
	projectId: string,
	devPort: number,
	opencodePort: number,
): Promise<SetupProjectFilesystemResult> {
	const projectPath = getProjectPath(projectId);
	const productionPort = await allocateProjectProductionPort(projectId);

	// Ensure projects directory exists
	await fs.mkdir(getProjectsPath(), { recursive: true });

	// Copy template to preview directory
	const previewPath = getProjectPreviewPath(projectId);
	await fs.mkdir(previewPath, { recursive: true });
	await copyTemplate(previewPath);
	logger.debug({ previewPath }, "Copied template to preview directory");

	// Create production directory
	const productionPath = getProjectProductionPath(projectId);
	await fs.mkdir(productionPath, { recursive: true });
	logger.debug({ productionPath }, "Created production directory");

	// Write .env file with all port configuration
	await writeProjectEnv(
		projectPath,
		devPort,
		opencodePort,
		projectId,
		productionPort,
	);
	logger.debug(
		{ devPort, opencodePort, productionPort, projectId },
		"Wrote project .env file",
	);

	// Create logs directories
	await fs.mkdir(path.join(previewPath, "logs"), { recursive: true });
	await fs.mkdir(path.join(productionPath, "logs"), { recursive: true });

	return { projectPath, productionPort };
}

/**
 * Update opencode.json with the selected model.
 */
export async function updateOpencodeModel(
	projectPath: string,
	model: string,
): Promise<void> {
	const opencodeJsonPath = path.join(projectPath, "opencode.json");

	try {
		// Read existing config
		const content = await fs.readFile(opencodeJsonPath, "utf-8");
		const config = JSON.parse(content);

		// Update the model field
		config.model = model;

		// Write back to file
		await fs.writeFile(opencodeJsonPath, JSON.stringify(config, null, 2));
	} catch (error) {
		logger.warn(
			{ projectPath, model, error: String(error) },
			"Failed to update opencode.json with model",
		);
		// Don't throw - this is not a critical failure
	}
}

/**
 * Copy the template directory to a new project directory.
 */
async function copyTemplate(targetPath: string): Promise<void> {
	const templatePath = getTemplatePath();

	// Check if template exists
	try {
		await fs.access(templatePath);
	} catch {
		throw new Error(`Template not found at ${templatePath}`);
	}

	// Copy recursively
	await copyDir(templatePath, targetPath);
}

/**
 * Recursively copy a directory.
 */
async function copyDir(src: string, dest: string): Promise<void> {
	await fs.mkdir(dest, { recursive: true });
	const entries = await fs.readdir(src, { withFileTypes: true });

	for (const entry of entries) {
		const srcPath = path.join(src, entry.name);
		const destPath = path.join(dest, entry.name);

		if (entry.isSymbolicLink()) {
			// Preserve symlinks (important for pnpm node_modules)
			const linkTarget = await fs.readlink(srcPath);
			await fs.symlink(linkTarget, destPath);
		} else if (entry.isDirectory()) {
			await copyDir(srcPath, destPath);
		} else {
			await fs.copyFile(srcPath, destPath);
		}
	}
}

/**
 * Write the .env file for a project with ports and volume configuration.
 */
async function writeProjectEnv(
	projectPath: string,
	devPort: number,
	opencodePort: number,
	projectId: string,
	productionPort: number,
): Promise<void> {
	const volumeName = `doce_${projectId}_data`;
	const envContent = `# Generated by doce.dev
DEV_PORT=${devPort}
OPENCODE_PORT=${opencodePort}
PRODUCTION_PORT=${productionPort}
PROJECT_DATA_VOLUME_NAME=${volumeName}
PROJECT_ID=${projectId}
NODE_ENV=development
`;

	await fs.writeFile(path.join(projectPath, ".env"), envContent);
}
